{"version":3,"file":"dicty-components-page-editor.esm.js","sources":["../src/components/buttons/MarkButton.tsx","../src/components/buttons/BlockButton.tsx","../src/components/Toolbar.tsx","../src/components/Element.tsx","../src/components/Leaf.tsx","../src/components/PageEditor.tsx"],"sourcesContent":["import React, { MouseEvent } from \"react\"\nimport { Editor } from \"slate\"\nimport { useSlate, ReactEditor } from \"slate-react\"\nimport IconButton from \"@material-ui/core/IconButton\"\nimport { MarkFormat } from \"../../types\"\n\n/**\n * isMarkActive determines if the current text selection contains an\n * active mark\n */\nconst isMarkActive = (editor: ReactEditor, format: MarkFormat) => {\n  // get a list of marks from the selected text\n  const marks = Editor.marks(editor)\n\n  // if there are marks for specified format then the mark is active\n  if (marks && marks[format]) {\n    return true\n  } else {\n    return false\n  }\n}\n\n/**\n * toggleMark will either remove or add a mark to the given text selection\n */\nconst toggleMark = (editor: ReactEditor, format: MarkFormat) => {\n  // first find if the selection's mark is currently active\n  const isActive = isMarkActive(editor, format)\n\n  // we either want to add or remove a mark based on whether it is currently active\n  if (isActive) {\n    Editor.removeMark(editor, format)\n  } else {\n    Editor.addMark(editor, format, true)\n  }\n}\n\ntype Props = {\n  /** Type of mark */\n  format: MarkFormat\n  /** Icon to display in button */\n  icon: JSX.Element\n}\n\n/**\n * MarkButton displays a button with associated click logic for toggling a mark.\n */\nconst MarkButton = ({ format, icon }: Props) => {\n  const editor = useSlate()\n\n  // when button is clicked, toggle the mark within the editor\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    event.preventDefault()\n    toggleMark(editor, format)\n  }\n\n  return (\n    <IconButton size=\"small\" onClick={handleClick}>\n      {icon}\n    </IconButton>\n  )\n}\n\nexport default MarkButton\n","import React, { MouseEvent } from \"react\"\nimport { Editor, Transforms, Element as SlateElement } from \"slate\"\nimport { useSlate, ReactEditor } from \"slate-react\"\nimport IconButton from \"@material-ui/core/IconButton\"\nimport { BlockFormat } from \"../../types\"\n\n/**\n * PROCESS:\n *\n * 1. User clicks button\n * 2. We run generator function to find any matching nodes for that block type.\n * 3. If there are no matches (value == undefined) then the generator is done\n *    and we do not mark that block as active.\n * 4. If the block is not active, then we set the nodes to match that format type.\n * 5. If the generator does find a match, we mark that block as active for the\n *    first matching node.\n * 6. If the block is active, then we set the nodes back to the default type of\n *    'paragraph'.\n */\n\n/**\n * isBlockActive determines if the current text selection contains an active block\n */\nconst isBlockActive = (editor: ReactEditor, format: BlockFormat) => {\n  // Editor.nodes returns a generator that iterates through all of the editor's\n  // nodes. We are looking for matches for the selected format.\n  // https://github.com/ianstormtaylor/slate/blob/master/packages/slate/src/interfaces/node.ts#L467\n  const nodeGenerator = Editor.nodes(editor, {\n    match: (n) =>\n      !Editor.isEditor(n) && SlateElement.isElement(n) && n.type === format,\n  })\n\n  // run the generator to find the nearest match\n  // then return true if this is the last value\n  const node = nodeGenerator.next()\n  while (!node.done) {\n    return true\n  }\n  return false\n}\n\n/**\n * toggleBlock will set the appropriate nodes for the given selection\n */\nconst toggleBlock = (editor: ReactEditor, format: BlockFormat) => {\n  // first find if the selected block is currently active\n  const isActive = isBlockActive(editor, format)\n\n  // Transforms provides helper functions to interact with the document.\n  // setNodes is used to set properties at the specified location.\n  // Here we are setting the type as paragraph if the block is active for the\n  // given format, otherwise we set it as the format.\n  Transforms.setNodes(editor, {\n    type: isActive ? \"paragraph\" : format,\n  })\n}\n\ntype Props = {\n  /** Type of block */\n  format: BlockFormat\n  /** Icon to display in button */\n  icon: JSX.Element\n}\n\n/**\n * BlockButton displays a button with associated click logic for toggling a block.\n */\nconst BlockButton = ({ format, icon }: Props) => {\n  const editor = useSlate()\n\n  // when button is clicked, toggle the block within the editor\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    event.preventDefault()\n    toggleBlock(editor, format)\n  }\n\n  return (\n    <IconButton size=\"small\" onClick={handleClick}>\n      {icon}\n    </IconButton>\n  )\n}\n\nexport default BlockButton\n","import React from \"react\"\nimport MarkButton from \"./buttons/MarkButton\"\nimport BlockButton from \"./buttons/BlockButton\"\nimport {\n  MdFormatBold,\n  MdFormatItalic,\n  MdFormatUnderlined,\n  MdFormatStrikethrough,\n  MdLooksOne,\n  MdLooksTwo,\n} from \"react-icons/md\"\nimport { FaSubscript } from \"react-icons/fa\"\n\n/**\n * Toolbar is the display for the editor toolbar.\n */\nconst Toolbar = () => {\n  return (\n    <div>\n      <MarkButton format=\"bold\" icon={<MdFormatBold />} />\n      <MarkButton format=\"italic\" icon={<MdFormatItalic />} />\n      <MarkButton format=\"underline\" icon={<MdFormatUnderlined />} />\n      <MarkButton format=\"strikethrough\" icon={<MdFormatStrikethrough />} />\n      <MarkButton format=\"subscript\" icon={<FaSubscript />} />\n      <BlockButton format=\"h1\" icon={<MdLooksOne />} />\n      <BlockButton format=\"h2\" icon={<MdLooksTwo />} />\n    </div>\n  )\n}\n\nexport default Toolbar\n","import React from \"react\"\nimport { RenderElementProps } from \"slate-react\"\nimport Typography from \"@material-ui/core/Typography\"\n\n/**\n * Element is used to render blocks based on a given type.\n */\nconst Element = ({ attributes, children, element }: RenderElementProps) => {\n  switch (element.type) {\n    case \"h1\":\n      return (\n        <Typography variant=\"h1\" {...attributes}>\n          {children}\n        </Typography>\n      )\n    case \"h2\":\n      return (\n        <Typography variant=\"h2\" {...attributes}>\n          {children}\n        </Typography>\n      )\n    default:\n      return (\n        <Typography component=\"p\" variant=\"body1\" {...attributes}>\n          {children}\n        </Typography>\n      )\n  }\n}\n\nexport default Element\n","import React from \"react\"\nimport { RenderLeafProps } from \"slate-react\"\n\n/**\n * Leaf is used to render text based on a given style.\n */\nconst Leaf = ({ attributes, children, leaf }: RenderLeafProps) => {\n  if (leaf.bold) {\n    children = <strong>{children}</strong>\n  }\n\n  if (leaf.italic) {\n    children = <em>{children}</em>\n  }\n\n  if (leaf.underline) {\n    children = <u>{children}</u>\n  }\n\n  if (leaf.strikethrough) {\n    children = <s>{children}</s>\n  }\n\n  if (leaf.subscript) {\n    children = <sub>{children}</sub>\n  }\n\n  return <span {...attributes}>{children}</span>\n}\n\nexport default Leaf\n","import React, { useCallback, useMemo, useState } from \"react\"\nimport { createEditor, Node } from \"slate\"\nimport { Slate, Editable, withReact } from \"slate-react\"\nimport Toolbar from \"./Toolbar\"\nimport Element from \"./Element\"\nimport Leaf from \"./Leaf\"\n\nconst initialValue = [\n  {\n    type: \"paragraph\",\n    children: [{ text: \"A line of text in a paragraph.\" }],\n  },\n]\n\n/**\n * PageEditor is the main editor component.\n */\nconst PageEditor = () => {\n  // create a slate editor object that won't change across renders\n  const editor = useMemo(() => withReact(createEditor()), [])\n  // store the value of the editor\n  const [value, setValue] = useState<Node[]>(initialValue)\n  // render expected element based on type passed as props\n  // memoize this function for subsequent renders\n  const renderElement = useCallback((props) => <Element {...props} />, [])\n  // render expected leaf based on type (i.e. bold, italic, etc)\n  const renderLeaf = useCallback((props) => <Leaf {...props} />, [])\n\n  return (\n    <Slate editor={editor} value={value} onChange={(value) => setValue(value)}>\n      <Toolbar />\n      <Editable renderElement={renderElement} renderLeaf={renderLeaf} />\n    </Slate>\n  )\n}\n\nexport default PageEditor\n"],"names":["isMarkActive","editor","format","marks","Editor","toggleMark","isActive","removeMark","addMark","MarkButton","icon","useSlate","handleClick","event","preventDefault","React","IconButton","size","onClick","isBlockActive","nodeGenerator","nodes","match","n","isEditor","SlateElement","isElement","type","node","next","done","toggleBlock","Transforms","setNodes","BlockButton","Toolbar","MdFormatBold","MdFormatItalic","MdFormatUnderlined","MdFormatStrikethrough","FaSubscript","MdLooksOne","MdLooksTwo","Element","attributes","children","element","Typography","variant","component","Leaf","leaf","bold","italic","underline","strikethrough","subscript","initialValue","text","PageEditor","useMemo","withReact","createEditor","useState","value","setValue","renderElement","useCallback","props","renderLeaf","Slate","onChange","Editable"],"mappings":"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"}